/*! jQuery Sticker - v0.6.6 - 2014-01-25
* https://github.com/amazingSurge/jquery-sticker
* Copyright (c) 2014 amazingSurge; Licensed GPL */
(function(window, document, $, undefined) {
	"use strict";

	var $window = $(window),
		windowHeight = $window.height();

	var Global = {
		count: 0,
		started: false,
		instances: [],
		types: {},
		generateId: function() {
			this.count++;
			return this.count;
		},
		scroll: function() {
			$.each(Global.instances, function(i, instance) {
				if (instance.enabled) {
					Global.types[instance.type].scroll(instance);

					// fire custom scroll callback
					if ($.isFunction(instance.options.scroll)) {
						instance.options.scroll.call(instance);
					}
				}
			});
		},
		resize: function() {
			windowHeight = $window.height();

			$.each(Global.instances, function(i, instance) {
				if (instance.enabled) {
					Global.types[instance.type].resize(instance);
					Global.types[instance.type].scroll(instance);

					// fire custom resize callback
					if ($.isFunction(instance.options.resize)) {
						instance.options.resize.call(instance);
					}
				}
			});
		},
		start: function() {
			if (!this.started) {
				$window.on('scroll', this.scroll);
				$window.on('resize', this.resize);
				this.started = true;
			}
		},
		stop: function() {
			this.started = false;
			$window.off('scroll', this.scroll);
			$window.off('resize', this.resize);
		}
	};

	// Constructor
	var Sticker = $.Sticker = function(element, options) {
		this.element = element;
		this.$element = $(element);

		// Get the type
		this.type = (options.type !== undefined) ? options.type : Sticker.defaults.type;
		// Merge the options
		this.options = $.extend({}, Sticker.defaults, Global.types[this.type].defaults, options);

		this.enabled = false;
		this.sticky = false;

		// Namespacing
		var namespace = this.options.namespace;

		// Class
		this.classes = {};
		this.classes.wrapper = namespace + '-wrapper';
		this.classes.enabled = namespace + '_enabled';
		this.classes.sticky = namespace + '_sticky';

		this.components = {};

		// Initialization
		this.init();
	};

	// Default options for the plugin as a simple object
	Sticker.defaults = {
		namespace: 'sticker', // String: Prefix string attached to the class of every element generated by the plugin,
		type: 'top', // String: Select your sticky type, "top", "bottom", "fill" or "sidebar"

		// Callback API
		init: null, // Callback: function() - Fires when init
		destroy: null, // Callback: function() - Fires when destroy
		scroll: null, // Callback: function() - Fires when scroll
		resize: null, // Callback: function() - Fires when resize
		enable: null, // Callback: function() - Fires when enable sticky
		disable: null, // Callback: function() - Fires when disable sticky
		sticky: null, // Callback: function() - Fires when sticky
		unsticky: null // Callback: function() - Fires when unsticky
	};

	Sticker.registerType = function(name, type) {
		Global.types[name] = type;
	};

	Sticker.prototype = {
		constructor: Sticker,
		init: function() {
			this.id = Global.generateId();

			var $wrapper = $('<div></div>').addClass(this.classes.wrapper);

			var id = this.$element.attr('id');

			if (typeof id !== 'undefined') {
				$wrapper.attr('id', id + '-' + this.options.namespace + '-wrapper');
			}

			this.$element.wrapAll($wrapper);
			this.$wrapper = this.$element.parent();

			//initial type
			Global.types[this.type].init(this);

			// fire custom init callback
			if ($.isFunction(this.options.init)) {
				this.options.init.call(this);
			}
			this.enable();

			Global.instances.push(this);
			Global.start();

		},
		destroy: function() {
			this.$element.unwrap();

			for (var i in Global.instances) {
				if (Global.instances[i].id === this.id) {
					Global.instances.splice(i, 1);
				}
			}

			if (Global.instances.length === 0) {
				Global.stop();
			}

			if ($.isFunction(this.options.destroy)) {
				this.options.destroy.call(this);
			}
		},
		enable: function() {
			this.enabled = true;
			Global.types[this.type].enable(this);
			this.$wrapper.addClass(this.classes.enabled);
			Global.types[this.type].scroll(this);

			// fire custom enable callback
			if ($.isFunction(this.options.enable)) {
				this.options.enable.call(this);
			}
		},
		disable: function() {
			this.enabled = false;
			this.sticky = false;
			Global.types[this.type].disable(this);
			this.$wrapper.removeClass(this.classes.sticky).removeClass(this.classes.enabled);

			// fire custom disable callback
			if ($.isFunction(this.options.disable)) {
				this.options.disable.call(this);
			}
		},
		on: function(e, callback) {
			if (typeof e === "string" && typeof callback === "function") {
				this.options[e] = callback;
			}
		},
		off: function(e) {
			if (typeof e === "string") {
				this.options[e] = null;
			}
		},
		set: function(option, value) {
			this.options[option] = value;
		},
		update: function() {
			if (this.enabled) {
				Global.types[this.type].scroll(this);
			}
		}
	};

	Sticker.registerType('top', {
		defaults: {
			topSpace: 0
		},
		init: function(api) {},
		scroll: function(api) {
			// in this case, the element should not have margin top and bottom value
			var scrollTop = $window.scrollTop(),
				elementTop = api.$wrapper.offset().top,
				topSpace = api.options.topSpace;
			if (topSpace > elementTop && elementTop >= 0) {
				topSpace = elementTop;
			}

			var extra = elementTop - topSpace - scrollTop;
			if (extra < 0) {
				if (!api.sticky) {
					api.sticky = true;
					api.$wrapper.addClass(api.classes.sticky);
					api.$element.css({
						position: 'fixed',
						top: topSpace
					});
					// fire custom sticky callback
					if ($.isFunction(api.options.sticky)) {
						api.options.sticky.call(api);
					}
				}
			} else {
				if (api.sticky) {
					api.sticky = false;
					api.$wrapper.removeClass(api.classes.sticky);
					api.$element.css({
						position: '',
						top: ''
					});
					// fire custom unsticky callback
					if ($.isFunction(api.options.unsticky)) {
						api.options.unsticky.call(api);
					}
				}
			}
		},
		resize: function(api) {
			api.$wrapper.css('height', api.$element.outerHeight(true));
		},
		enable: function(api) {
			api.$wrapper.css('height', api.$element.outerHeight(true));
		},
		disable: function(api) {
			api.$element.css({
				position: '',
				top: ''
			});
			api.$wrapper.css('height', '');
		}
	});
	Sticker.registerType('fill', {
		defaults: {
			useFlex: true,
			check: true,
			callback: null // Callback: function(api) - Fires when fill,
		},
		init: function(api) {
			if (!api.options.useFlex || !this.vhSupport() || !this.flexSupport()) {
				api.options.useFlex = false;
			}

			api.paddingBottom = parseInt(api.$element.css("padding-bottom"), 10);
		},
		scroll: function(api) {
			if (api.options.useFlex) return;

			var scrollTop = $window.scrollTop(),
				documentHeight = $('body').height();

			if (scrollTop === 0 && documentHeight <= windowHeight) {
				if (!api.sticky) {
					api.sticky = true;
					api.$wrapper.addClass(api.classes.sticky);
					api.$element.css("padding-bottom", windowHeight - documentHeight + api.paddingBottom);
					// fire custom sticky callback
					if ($.isFunction(api.options.sticky)) {
						api.options.sticky.call(api);
					}
				}
			} else {
				if (api.sticky) {
					api.sticky = false;
					api.$wrapper.removeClass(api.classes.sticky);
					api.$element.css("padding-bottom", '');
					// fire custom unsticky callback
					if ($.isFunction(api.options.unsticky)) {
						api.options.unsticky.call(api);
					}
				}
			}

			// fire custom callback
			if ($.isFunction(api.options.callback)) {
				api.options.callback.call(api, scrollTop, documentHeight, windowHeight);
			}
		},
		resize: function(api) {
			if (api.options.useFlex) return;

			api.$element.css("padding-bottom", '');
			api.paddingBottom = parseInt(api.$element.css("padding-bottom"), 10);
			api.sticky = false;
		},
		enable: function(api) {
			if (api.options.useFlex) {
				api.$wrapper.parent().addClass(api.options.namespace + '_fill-container');
				api.$wrapper.addClass(api.options.namespace + '_fill');
			} else {
				if (api.options.check) {
					var original = $('body').height();
					api.checkInterval = setInterval(function() {
						if (original !== $('body').height()) {
							Global.types[api.type].scroll(api);
							original = $('body').height();
						}
					}, 500);
				}
			}
		},
		disable: function(api) {
			if (api.options.useFlex) {
				api.$wrapper.parent().removeClass(api.options.namespace + '-fill-container');
				api.$wrapper.removeClass(api.options.namespace + '-fill');
			} else {
				if (api.options.check) {
					clearInterval(api.checkInterval);
				}
				api.$element.css("padding-bottom", '');
			}
		},
		flexSupport: function() {
			var b = document.body || document.documentElement;
			var s = b.style;
			var t = 'boxDirection';
			if (typeof s[t] == 'string') {
				return true;
			}
			var browsers = ['Moz', 'Webkit', 'Khtml', 'O', 'ms'],
				t = t.charAt(0).toUpperCase() + t.substr(1);
			for (var i = 0; i < browsers.length; i++) {
				if (typeof s[browsers[i] + t] == 'string') {
					return true;
				}
			}
			return false;
		},
		vhSupport: function() {
			var $elem = $('<div style="height:50vh;visibility:hidden;" />').appendTo('body'),
				height = parseInt(window.innerHeight / 2, 10),
				compStyle = parseInt((window.getComputedStyle ?
					getComputedStyle($elem.get(0), null) :
					$elem.get(0).currentStyle)["height"], 10);
			$elem.remove();
			return compStyle === height;
		}
	});

	Sticker.registerType('sidebar', {
		defaults: {
			topSpace: 0, // how many pixels to pad the element from the top of the window
			bottom: null, // Callback: function() - Fires when bottom
			unbottom: null // Callback: function() - Fires when unbottom
		},
		init: function(api) {

		},
		scroll: function(api) {
			var topSpace = api.options.topSpace,
				scrollTop = $window.scrollTop() + topSpace,
				elementHeight = api.$element.outerHeight(),
				parentHeight = api.$parent.height(),
				borderTop = parseInt(api.$parent.css("border-top-width"), 10),
				paddingTop = parseInt(api.$parent.css("padding-top"), 10),
				parentTop = api.$parent.offset().top + borderTop + paddingTop,
				elementTop = api.$element.offset().top - parseInt(api.$element.css("padding-top"), 10),
				willBottom, paddingBottom;

			if (!api.sticky && scrollTop > elementTop) {
				api.sticky = true;
				api.$wrapper.addClass(api.classes.sticky);
				api.$element.css({
					position: 'fixed',
					top: topSpace
				});

				// fire custom unsticky callback
				if ($.isFunction(api.options.sticky)) {
					api.options.sticky.call(api);
				}
			} else if (api.sticky) {
				if (scrollTop < parentTop) {
					api.sticky = false;
					api.$wrapper.removeClass(api.classes.sticky);
					api.$element.css({
						position: '',
						top: '',
						bottom: ''
					});

					// fire custom unsticky callback
					if ($.isFunction(api.options.unsticky)) {
						api.options.unsticky.call(api);
					}
				} else {
					willBottom = scrollTop + elementHeight > parentHeight + parentTop;
					if (willBottom) {
						api.bottomed = true;

						paddingBottom = parseInt(api.$parent.css("padding-bottom"), 10),

						api.$element.css({
							position: "absolute",
							bottom: paddingBottom,
							top: ""
						});

						// fire custom bottom callback
						if ($.isFunction(api.options.bottom)) {
							api.options.bottom.call(api);
						}
					} else if (api.bottomed) {
						api.bottomed = false;

						api.$element.css({
							position: 'fixed',
							bottom: '',
							top: topSpace
						});
						// fire custom unbottom callback
						if ($.isFunction(api.options.unbottom)) {
							api.options.unbottom.call(api);
						}
					}
				}
			}
		},
		resize: function(api) {

		},
		enable: function(api) {
			var elementHeight = api.$element.outerHeight(),
				elementWidth = api.$element.outerWidth(true),
				float = api.$element.css("float"),
				display = api.$element.css("display"),
				verticalAlign = api.$element.css("vertical-align");

			if (float == 'none') {
				api.$element.width(api.$element.width());
			}
			api.$wrapper.css({
				width: elementWidth,
				height: elementHeight,
				display: display,
				"vertical-align": verticalAlign,
				float: float
			});

			api.$parent = api.$wrapper.parent();
			api.$parent.css('position', 'relative');

			api.bottomed = false;
			api.sticky = false;
		},
		disable: function(api) {
			api.$wrapper.css({
				width: '',
				height: '',
				display: '',
				"vertical-align": '',
				float: ''
			});
			api.$element.css({
				position: '',
				top: ''
			});
		}
	});

	// Collection method.
	$.fn.sticker = function(options) {
		if (typeof options === 'string') {
			var method = options;
			var method_arguments = arguments.length > 1 ? Array.prototype.slice.call(arguments, 1) : undefined;

			return this.each(function() {
				var api = $.data(this, 'sticker');

				if (api && typeof api[method] === 'function') {
					api[method].apply(api, method_arguments);
				}
			});
		} else {
			return this.each(function() {
				if (!$.data(this, 'sticker')) {
					$.data(this, 'sticker', new Sticker(this, options));
				}
			});
		}
	};
}(window, document, jQuery));
